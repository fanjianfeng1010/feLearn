####运行机制
代码自上而下执行
=>基本数据类型的值会存储在当前作用域下
```javascript 
   var a = 12
```
1) 首先开辟一个内存空间储存12
2) 在当前作用域中声明一个变量a
3) 让声明的变量和储存的12进行关联

基本数据类型（也叫值类型），是按照值来操作的:吧原有的值复制一份，放到新的空间或位置上，和原来的值没有关系

引用类型数据的值不能直接储存到当前作用域下（因为可能储存的内容过于复杂），我们需要先开辟一个新的空间（理解为仓库），把内容存储到这个空间中


 ```javascript 
 var obj1 = {n:100}
 ```
 1)首先开辟一个新的内存空间，把对象中的键值对依次储存起来（为了保证后面可以找到这个空间，此空间有一个16进制的地址）
 2）声明一个变量
 3）让变量和空间地址关联在一起（把空间地址复制给变量）

#####栈内存
  本身就是提供JS代码执行的环境
  所有的基本类型都会直接在栈内存中开辟一个位置进行储存

#####堆内存
  用来存储引用类型中的信息值的空间
    对象存储的是键值对
    函数存储的是代码字符串

```javascript 
  var obj = {
    n:10,
    m:obj.n * 10
  }
  console.log(obj.m)
````
####思考，上述代码运行结果是什么？为什么？
运行结果：
   TypeError: Cannot read property 'n' of undefined
   解答：
JavaScript在运行代码时会先形成一个全局作用域（栈内存）
代码由上而下执行
首先开辟一个新的堆内存（AAFF1111）,把键值对存储到对内存中
```javascript
  n: 10, 
  m: obj * 10 
   //此时，堆内存信息还没有存储完成，空间地址还没有给obj,
   //此时obj就是undefined，而undefined是基本类型，基本类型是没有属性值的，所以会报错
```


###js中的判断操作语句
1、if/else 
```javascript
  var num = 12
  if(num > 10) {
    num++
  } else if(num >= 0 && num <= 10) {
      num--
  } else {
    num += 2
  }
```

###三目运算符
```
condition ？ statements ：statements
```
如果要执行多条语句，此时用小括号包裹起来，并用逗号分隔即可

###函数
>在JS中，函数就是一个方法，基于函数一般都是为了实现某个功能

**函数诞生的目的就是为了封装：把实现一个功能的代码封装到到一个函数中忙早起想要实现这个功能，只需要把函数执行即可，不必要再次编写重复的代码，起到了低耦合高内聚的作用

=====
ES6标准中创建箭头函数
let 函数名(变量名) =（[参数]） => {
  函数体
}

函数作为引用类型中的一种，他也是按照引用地址来操作的
***函数的储存，
  函数被创建后，会在堆内存中开辟一个内存空间，把函数里面的语句以’字符串‘的形式储存在其中，然后把储存这个空间的地址赋值给函数名

***函数的助兴
  目的：把之前存储到堆内存中的代码字符串变为真正的JS代码自上而下执行，从而实现应有的功能

  1.函数执行，首先会形成一个私有的作用域（一个代码执行的环境，也是一个栈内存）
  2.吧之前在堆内存中存储的字符串复制一份过来，变为真正的JS代码，在新开辟的作用域中自上而下执行

  ***函数的参数
  >参数是函数的入口：当我们在函数中封装一个功能，发现一些原材料不确定，需要执行函数的时候用户传递进来才可以，此时我们就基于参数的机制，提供出入口即可
```javascript
  
```

### 2019.02.24 JS中的数据转换

JS中的数据类型分为
【基本数据类型】
  数字 number
  字符串 string
  空 null
  未定义 undefined

【引用数据类型】
  对象 object
    普通对象
    数组对象
    正则对象
    日期对象
    数学函数
    。。。
  函数

  真是项目中，根据需求，我们往往需要把数据类型之间进行转换

  ### 把其他类型数据类型转换为number类型
  `1.发生情的情况`
  -isNaN检测的时候：当检测的值不是数字类型，浏览器会自动调用number方法把他先转换为数字，然后再检测是否为有效数字
  ```javascript
    isNaN('3') => false
    Number('3') => 3
    isNaN(3) => false

  ```
  - 基于parseInt/parseFloat/Number 手动转换为数字类型
  - 数学运算：+ - * 、 % ，但是’+‘ 不仅仅是数学运算符，还坑是字符串拼接
  ```javascript
    '3' - 1 => 2
    Number('3') => 3
    3 - 1 => 2

    '3px' - 1 => NaN

    '3px' + 1 => '3px1' => 字符串拼接

    var i = '3'
    i = i + 1 => '31'
    i += 1 => '31'
    i++ => 4 i++ 就是单纯的数学运算，已经摈弃掉字符串拼接规则
  ```
  - 在基于"=="比较的时候，有时候也会把其他值转换为数字类型
  - ...

`2.转换规律`
```javascript
    // 转换方法 Number（浏览器自行转换的都是基于这个方法）

    【把字符串转换为数字】
    只要遇到一个非有效数字字符，结果就是NaN
    '0' => 0
    ' ' => 0
    '\n' => 0
    '\t' => 0

    【把布尔类型转换为数字】
    true => 1
    false => 0

    【把没有转换为数字】
    null => 0
    undefined => NaN //#endregion

    【把引用类型转换为数字】
    首先都县转换为字符串，然后再转换为数字
```
### 把其他类型值转换为字符串
`1.发生的情况`
- 基于alert/confirm 等方法输出内容的时候，会把里面的内容转换为字符串再输出
- 基于 "+"进行字符串拼接的时候
- 吧引用类型值转换为数字的时候，首先会转换为字符串，然后再转换为数字
- 给对象设置属性名，如果不是字符串，首先转换为字符串，然后再当做属性储存到对象中（对象的属性只能是数字或者字符串）
- 手动调用toString/toFixed/join/String等方法的时候

#### 转换规律
- 引用类型基本都是调用toString方法
- 基本类型基本都是直接转换为字符串
- 【对象】
- => 不管是怎样的普通对象 转换结果都为 '[object object]'


### 把其他类型转换为布尔类型
`1.发生的情况`
- 基于 !/!!/Boolean等方法转换
- 基于条件判断的条件最后都会转换为布尔类型

`2.转换的规律`
只有"0/NaN/''/null/undefined 五个值转换为布尔的false，其余都是转换为true

### 特殊情况：数学运算和字符串拼接‘+’
- 当表达式中出现字符串，就是字符串拼接，否则就是数学运算