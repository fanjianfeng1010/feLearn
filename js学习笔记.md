####运行机制
代码自上而下执行
=>基本数据类型的值会存储在当前作用域下
```javascript 
   var a = 12
```
1) 首先开辟一个内存空间储存12
2) 在当前作用域中声明一个变量a
3) 让声明的变量和储存的12进行关联

基本数据类型（也叫值类型），是按照值来操作的:吧原有的值复制一份，放到新的空间或位置上，和原来的值没有关系

引用类型数据的值不能直接储存到当前作用域下（因为可能储存的内容过于复杂），我们需要先开辟一个新的空间（理解为仓库），把内容存储到这个空间中


 ```javascript 
 var obj1 = {n:100}
 ```
 1)首先开辟一个新的内存空间，把对象中的键值对依次储存起来（为了保证后面可以找到这个空间，此空间有一个16进制的地址）
 2）声明一个变量
 3）让变量和空间地址关联在一起（把空间地址复制给变量）

#####栈内存
  本身就是提供JS代码执行的环境
  所有的基本类型都会直接在栈内存中开辟一个位置进行储存

#####堆内存
  用来存储引用类型中的信息值的空间
    对象存储的是键值对
    函数存储的是代码字符串

```javascript 
  var obj = {
    n:10,
    m:obj.n * 10
  }
  console.log(obj.m)
````
####思考，上述代码运行结果是什么？为什么？
运行结果：
   TypeError: Cannot read property 'n' of undefined
   解答：
JavaScript在运行代码时会先形成一个全局作用域（栈内存）
代码由上而下执行
首先开辟一个新的堆内存（AAFF1111）,把键值对存储到对内存中
```javascript
  n: 10, 
  m: obj * 10 
   //此时，堆内存信息还没有存储完成，空间地址还没有给obj,
   //此时obj就是undefined，而undefined是基本类型，基本类型是没有属性值的，所以会报错
```


###js中的判断操作语句
1、if/else 
```javascript
  var num = 12
  if(num > 10) {
    num++
  } else if(num >= 0 && num <= 10) {
      num--
  } else {
    num += 2
  }
```

###三目运算符
```
condition ？ statements ：statements
```
如果要执行多条语句，此时用小括号包裹起来，并用逗号分隔即可

###函数
>在JS中，函数就是一个方法，基于函数一般都是为了实现某个功能

**函数诞生的目的就是为了封装：把实现一个功能的代码封装到到一个函数中忙早起想要实现这个功能，只需要把函数执行即可，不必要再次编写重复的代码，起到了低耦合高内聚的作用

=====
ES6标准中创建箭头函数
let 函数名(变量名) =（[参数]） => {
  函数体
}

函数作为引用类型中的一种，他也是按照引用地址来操作的
***函数的储存，
  函数被创建后，会在堆内存中开辟一个内存空间，把函数里面的语句以’字符串‘的形式储存在其中，然后把储存这个空间的地址赋值给函数名

***函数的助兴
  目的：把之前存储到堆内存中的代码字符串变为真正的JS代码自上而下执行，从而实现应有的功能

  1.函数执行，首先会形成一个私有的作用域（一个代码执行的环境，也是一个栈内存）
  2.吧之前在堆内存中存储的字符串复制一份过来，变为真正的JS代码，在新开辟的作用域中自上而下执行

  ***函数的参数
  >参数是函数的入口：当我们在函数中封装一个功能，发现一些原材料不确定，需要执行函数的时候用户传递进来才可以，此时我们就基于参数的机制，提供出入口即可
```javascript
  
```