1. 什么是node？
  基于v8引擎渲染js的工具或者环境
  ->安装node
  ->把js代码放到node环境中执行

2. 如何在node中渲染和解析js
  -> REPL模式(输入-求值-输出-循环)
  ->直接基于node来执行js文件

3. 之所以把node作为后台编程语言，是因为
  1)我们可以把node安装在服务器上
  2)我们可以把编写的js代码放到服务器上，通过node来执行（我们可以JS来操作服务器，换句话说，使用JS来实现服务器端的一些功能操作）

4. node做后台的优势和特点
  =>单线程的
  =>基于v8引擎渲染:快
  =>异步无阻塞的I/O操作:对文件的读写
  =>event-driven事件驱动:类似基于发布订阅或者回调函数

5. 前端(浏览器运行js)是限制i/o操作的
    input type='file' 这种算是i/o操作，但是需要用户手动选择的(而且仅仅是一个读取不是写入)
   node中运行时不需要限制i/o操作的

6. NPM的应用
  目前“工程化/自动化”开发，都是基于node环境，基于npm管理模块，基于webpack实现模块之间的依赖打包，部署上线等


7. 在本地项目中基于npm/yarn安装第三方模块
  第一步:在本地项目中创建一个“package.json”的文件
    作用： 把当前项目所有的依赖第三方模块信息(包含：模块名称以及版本号等信息)都记录下来；可以在这里配置一些课执行的命令脚本等
    基于yarn安装会默认生成一个package.json，只是信息没有手动创建的全面

    npm init -y 自动生成package.json 生成的配置会详细很多

  第二步：安装
    开发依赖:只有在项目开发阶段依赖的第三方模块
    生产依赖:项目部署实施的时候，也需要依赖的第三方模块
    [npm]
      npm install xxx --save 保存到配置清单的生产依赖中
                      --save-dev 保存到开发依赖中

    [yarn]
      yarn add xxx 默认就是保存到生产依赖中
              --dev / -D 保存到开发依赖中

  第三步：部署的时候“跑环境”
    执行 npm install 或者yarn install 即可
    npm会自己先检测目录中是否有package.json，如果有，会按照文件中的配置清单依次安装

=> 开发一个项目，我们生成一个配置清单“package.json”，当我们安装第三方模块使用的时候，把安装的模块信息都记录到配置清单中，这样以后不管是团队协作开发还是项目部署上限，我们都没有必要吧node_modules发文件发给别人，只需要把配置清单传递给其他人即可，其他人拿到配置清单后，按照清单中依赖项以及版本号，重新安装即可(重新安装”跑环境“)


8. 安装在本地和全局的区别
  [全局]
    1. 所有的项目都可以使用这个模块
      ->容易导致版本冲突
      ->安装在全局的模块，不能基于commonJS规范调取使用（也就是说，不能基于require('xxx')调取使用）
    2. 为啥安装在全局可以使用命令
      -> 安装在全局目录下的模块，大部分都会生成一个xxx.cmd的文件，只要有这个文件，那么xxx就是一个可执行的命令

  [本地]
    1. 只能当前项目使用这个模块
      ->不能直接的使用命令操作(不能用lessc 编译less文件)
      ->安装在本地的模块想使用命令，需要配置package.json下的script属性
        -> 把模块安装在本地，如果是支持命令操作的(会在node_modules的bin中声场xxx.cmd命令文件，只不过这个文件无法再全局下执行 =》不能直接使用命令)
        -> 在package.json的script中配置需要执行的命令脚本
        "scripts": {
          "xxx1":"lessc -v" 属性名自己设置即可，属性值是需要执行的命令脚本，根据需要自己编写（可以配置还多命令）
        }
        -> npm run xxx1 / yarn xxx1 这样的操作就是把配置的脚本执行
          -> 首先到配置清单中的scripts中查找
          -> 找到后把后面对应的属性值(执行脚本)执行
          -> 执行脚本的时候，会到本地node_modules中的bin文件查找，没有的话，再向npm的全局目录下查找


9. node入门
  node本身是基于commonJS模块规范设计的，所以模块是node的组成
    - 内置模块：node天生提供给JS调取使用的
    - 三方模块：别人写好的，我们可以基于npm安装使用
    - 自定义模块，自己创建一些模块

  commonJS模块化设计的思想(AMD/CMD/ES6 MODULE都是模块设计思想)
  ```
  1.CommonJS规定，每一个js都是一个单独的模块（模块是私有的:里面设计的值和变量以及函数等都是私有的，和其他js文件中的内容是不冲突的）

  2.CommonJS中可以允许模块中的方法互相的调用
    B模块中想要调取A模块的方法
      ->A导出
      ->B导入

    [导出]
      CommonJS给每一个模块都设置了内置的变量/属性/方法
        module：代表当前这个模块对象
        module.exports：模块的这个属性是用来导出属性方法的
        export：是内置的一个变量。也是用来导出当前模块属性方法的，虽然和module.exports不是同一个东西，但是对应的值是同一个(module.exports = exports 值都是对象)

    [导入]
      require:CommonJS提供的内置变量，用来导入模块的(其实导入的就是module.exports暴露出来的东西)，导入的值也是[Object]类型的


  CommonJS模块的特点如下:
  1. 所有代码都运行在模块作用域，不会污染全局作用域。(每一个模块都是私有的，包括里面所有的东西也都是私有的，不会和其他模块产生干扰)
  2. 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
  3. 模块加载的顺序，按照其在代码中出现的顺序。
  4. CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作

  ```

  require导入规则
    require('./xxx') 或者 ../xxx 再或者 /xxx，这种自己制定路径的模式，都是为了导入自定义的模块，换句话说，想要导入自定义模块，必须加路径

    require('xxx') 首先到当前项目的node_modules钟查找是否存在这个模块，不存在再找node提供的内置模块(导入第三方或者内置的)


  __dirname:模块中这个内置变量是当前模块所在的绝对路径
  __filename:相对于__dirname来讲，多了模块名称


10. node中的内置模块
  `fs`内置模块

  ```javascript
    let fs = require('fs')

   /* 1. fs.mkdir / fs.mkdirSync : 创建文件夹，有sync的是同步创建，反之没有是异步想要实现无阻塞的I/O操作，都要用异步操作
      2. fs.readdir:读取文件夹中的内容
      3. fs.rmdir:删除文件夹 => 必须保证被删除的文件夹是空的
      4. fs.readFile:读取文件中的内容
      5. fs.writeFile:向文件中写入内容（覆盖写入：写入的新内容会替换原有的内容）
      6. fs.appendFile:追加写入新内容，原有的内容还在
      7. fs.copyFile:拷贝文件到新的位置
      8. fs.unlink: 删除文件
   */
  ```

  1. url内置模块
    url.parse(url[,flag]):把一个URL地址进行解析，把地址中的每一部分按照对象键值对的方式存储起来

  2. HTTP内置模块
    let server = http.createSever() // 创建web服务
    server.listen() // 监听端口

    注意：基于node创建后台程序，我们一般都创建一个server服务，在模块中实现创建web服务，和对于请求的处理（并且我们一般都会把server模块放到当前项目的根目录下）

    服务器上有一堆项目代码，这对项目代码中既可能有服务器端的程序代码，也有可能有客户端的程序代码，而客户端程序代码我们一般都放到static这个文件夹中

    ```
      static
        都是服务器端需要返回给客户端，有客户端浏览器渲染和解析的（前端项目：包括页面、CSS，JS、图片等）

      server.js
        都是需要在服务器端基于node执行的（后的项目：一般只有JS）
    ```

    我们创建的web服务需要处理两类请求：
      1.静态资源文件的请求处理：想向服务器取文件
      2.API接口的请求处理：想向服务器取资源
    
      区别：第一类请求地址中有后缀名，第二类没有后缀


------
1.本地存储 和 服务器存储

  本地存储：把一些信息存储到客户端本地 => （主要目的有很多，其中有一个就是实现多页面之间的信息共享）
  ->离线缓存（xxx.manifest） H5处理离线缓存还是存在一些硬伤，所以真实项目中一般还是传统的native app来完成这件事情
  ->localStorage / sessionStorage: H5中新增加的api，基于这个api可以把一些数据缓存到客户端本地（常用）
  ->indexedDB / webSQL:本地数据库存储
  ->Cookie：本地信息存储（常用）
  ->CacheStorage / ApplicationCache: 本地缓存存储


2.用到本地存储的地方：
  [页面之间信息的通信]
    A存储信息，B页面可以获取
      ->登录
      ->记住用户名密码 
      ->购物车
      ->跳转到其他页面，返回上级页面的时候停留在之前最后一次点击的位置
    需求一：
      A页面中有一个列表，点击列表中的每一项，跳转到B页面（详情页面），在B页面需要知道点击的是A中的哪条数据，从而展示不同的信息
        URL问号传参：B.html?xx=xxx(进入到B页面，首先把传递的参数获取到，根据传递的不同，我们从服务器端获取不同的数据，从而展示不同的内容)
        前提：需要时A中的某个操作可以跳转到B页面，此时才可以问号传参
    本地存储都是存储到当前浏览器指定的地方
      =>在谷歌浏览器存储的信息，在IE浏览器中获取不到=>本地存储信息无法夸浏览器传输
      =>存储的信息都是按照域来管理的
        => 例如：访问京东的网站，把信息都存储到JD.COM，其他网站中是无法直接获取这些信息的，本地存储是不能直接跨域访问的

    浏览器中有一个存储信息的地方，例如购物网站添加购物车的时候，在不同页面点击了物品添加进购物车，点击时就是把信息存储到浏览器存储信息的地方，此时其他页面也可以访问浏览器存储的信息

  [做一些性能优化]
    -> 把一些不经常改变的数据，在第一次从服务器端获取到之后，存储到客户端本地（记录一个存储时间），假设我买设置有效存储期10分钟，那么10分钟以内，我们再刷新页面，就不用再向服务器发送请求了，直接从本地数据获取展示即可；超过10分钟，重新向服务器发送请求，请求回来最新数据参考第一次，也一样存储到本地中
      =>减轻服务器压力
      =>对于不经常更新的数据，我们可以把存储周期设置长一些，有助于页面第二次加载的时候，渲染的速度（移动端经常这样做）


  localstorage VS cookie
    [cookie]
      1. 兼容所有的浏览器
      2. 有存储的大小限制，一般一个源(一个域)只能存储2kb的内容
      3. cookie有过期时间（当然我们自己可以手动设置这个时间）
      4. 杀毒软件或者浏览器的垃圾清理功能可能会把cookie信息强制清除掉
      5. 在隐私或者无痕浏览模式下，是不记录cookie的
      6. cookie不是严格的本地存储，因为要和服务器之间来回传输
    [localstorage]
      1. 不兼容IE8及以下
      2. 也有存储的大小限制，一个源下最多存储5MB作用
      3. 本地用久存储，只要你不手动删除，永远存储在本地（但是我们也是基于api removeItem/clear手动清除一些自己想要删除的信息）
      4. 杀毒软件或者浏览器的垃圾清理功能暂时不会清除localstorage(新版本谷歌浏览器会清除localstorage)
      5. 在隐私或者无痕模式下，是记录localstorage的
      6. localstorage和服务器没有关系

  真实项目中使用本地存储来完成一些需求的情况不是很多，一般都是基于服务器的session或者数据库存储完成的（服务器的session和本地的cookie是有关联的），
  如果不考虑兼容，就想基于本地存储来完成一些事情，那么一般都是用localstorage的（尤其是移动端开发）
    方法：
    localstorage.setItem([key],[value]):[value]必须是字符串格式的（即使写的不是字符串，也会默认转换为字符串）
    localstorage.getItem([key]):通过属性名获取存储的信息
    localstorage.removeItem([key])：删除指定的存储信息
    localstorage.key(0):基于索引获取指定的key名

    document.cookie= ''//=>设置cookie

