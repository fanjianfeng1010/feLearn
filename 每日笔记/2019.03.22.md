### 写出你所熟知的 ES6 的新语法，写出它们与 ES5 的区别

- let /const
  > 和 ES5 var 的区别
  > 1)let 不存在变量提升机制，变量不允许在声明前使用
  > 2)let 不循序重复声明 3)在全局作用域中基于 let 声明的变量不是 window 的一个属性，和它没关系
  > typeof 未声明变量 => 不是 undefined 而是报错(暂时性死区)
  > let 会形成块级作用域（类似私有作用域，大部分大括号都会形成私有作用域）
- 解构赋值
- “...” 扩展，剩余、展开运算符
- 箭头函数
  > 和普通函数的区别
  >
  > 1. 没有 arguments,但是可以基于...arg 获取实参集合(结果是一个数组)
  > 2. 没有自己的 this，箭头函数中的 this 是上下文中的 this
- ES6 模板字符串
- Promise
- class
- interator (for of 循环)
- Map / Set

### 重排(回流) 重绘

> 思路: 1.首先说出什么是重排和重绘
> 浏览器渲染一个页面的时候是按照'先创建 DOM 树-> 加载 css -> 生成渲染树 render tree -> 把渲染树交给浏览器（GPU）进行绘制'，如果后期我们修改了元素样式(但是没有改变大小和位置)，浏览器会把当前元素重新生成渲染树，然后重新渲染，这给机制就是重绘，但是一旦元素的位置或者大小等发生改变，浏览器就要从 DOM 树重新计算渲染，这个机制是回流（重排），不伦是重绘还是重排都非常消耗性能，在我以前的项目中，我特意的重视了这个问题，尽量减少 DOM 引发的回流和重绘的问题，重用的解决方案：
>
> 1. 需要动态向页面追加元素的时候，基于文档碎片或者先把需要增加的所有元素拼接成字符串，最后统一进行增加
> 2. 读写分离，把统一修改样式都放到一起执行，新版浏览器都有一个自己检测的机制，如果发现下面紧挨着的操作也是修改元素样式，会把所有修改的实现存起来，知道遇到非修改样式的操作，会把之前存储的统一执行，引发一次回流和重绘，
>    当然还有一些其他的办法，这些是最长注意的，我认为减少 DOM 的回流重绘是非常重要的性能优化手段之一 2.突出突出它们耗性能 3.突出自己写项目的时候重点注意了这些事情，以及自己的解决方案

### 写出下面代码运行的结果

```javascript
var str = "abc123",
  number = parseFloat(str);

if (num === NaN) {
  alert(NaN);
} else if (num === 123) {
  alert(123);
} else if (typeof num === "number") {
  alert("number");
} else {
  alert("str");
}

// 结果为 number；  因为paseFloat('abc123') 结果为NaN,NaN和任何类型比较都不相等包括和NaN本身比较，NaN是数字类型
```

### 写出代码执行结果

```javascript
var a = "abc" + 123 + 456;
alert(a); // 'abc123456'

var b = "456" - "123";
alert(b); // 333

var c = 1,
  d = "1";
var f = c > d ? (c < d ? c : d) : c == d ? c : d;
alert(f); // 1
```

### 用户昵称规定只能是数字、大小写字母，且最少不能少于 2 位，也不能超过 20 位，写个正则匹配这个需求

```javascript
var reg = /^[\da-zA-Z]{2,20}$/;
```

### 谈谈你对面向对象的理解

> JS 本身就是基于面向对象编程思想开发出来的语言，我们学习 js 就是在学习 js 中的类和实例，例如数组时 Array 的实例、对象是 Object 的实例、函数就是 Function 的实例，在泽泻内置类的原型上有很多公共的属性和方法，这些方法可以被实例调用，我们学习 js 就是学习这些方法

[面向对象真实项目的应用]
平时的原物逻辑开发，我买没有可以使用类的方式做，只有在一些组件或者插件封装的时候才会基于构造函数和原型链使用类和实例完成

[面向对象中的一些语法和特点]
所谓面向对象就是基于 class 或者 Function 创建一个雷，执行的时候 new 执行创建一个实例，这样实例就可以调取类上提供的方法，想要基于面向对象矩形插件封装，必须掌握类的继承、封装和多态，封装就是提取公共方法，JS 中没有严格意义的多态，不能进行方法的重写，常用继承方式有很多，例如原型继承，call 继承，寄生组合继承，es6 中的继承等，有些方法会存在一些问题

### js 中的 this 汇总

- this:当前方法执行的主题（谁执行这个方法，那么 this 就是谁，所以 this 和当前方法在哪里创建或者在哪里执行都没有必然的联系）
  > 1.给当前元素的某个时间绑定方法，方法中的 this 都是当前操作的元素本身

```javascript
document.body.onclick = function() {
  // this => body
};
```

> 2.函数执行，看函数前面是否有点，有点的话，点前面是谁，this 就是谁，没点就是 window，在严格模式下，没点 this 就是 undefined

```javascript
let fn = function() {
  console.log(this.name);
};

let obj = {
  name: "xx",
  fn: fn
};
fn(); // => this:window
obj.fn(); // this:obj
```

> 3. 构造函数执行，方法中的 this 一般都是当前类的实例

```javascript
let Fn = function() {
  this.x = 100;
};
let f = new Fn(); // =>this:f
```

> 4.箭头函数中没有自己的 this，this 是上下文中的 this

```javascript
let obj = {
  fn: function() {
    setTimeout(() => {
      // this:obj
      console.log(this);
    }, 1000);
  }
};
obj.fn(); // 因为箭头函数没有this，所以obj.fn执行时this.就是obj
```

> 5. 在小括号表达式中，会影响 this 的指向

```javascript
let obj = {
  fn: function() {
    //
    console.log(this);
  }
};
obj.fn(); // => this:obj
(12, obj.fn)(); // =>this:window
```

- 6.使用 call/apply/bind 可以改变 this 指向

```javascript
fn.call(obj); // => this:obj
fn.call(12); // => this:12
fn.call(); // => this:window(非严格模式下call/apply/bind第一个参数不写或者写null和undefined，this都是window，严格模式下写谁this是谁就是谁，不写就是undefined)
```

- 7.s
