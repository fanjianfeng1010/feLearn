### 高级单例模式

> 1.在个命名空间赋值的时候，不是直接赋值一个对象，而是先执行匿名函数，形成一个私有作用域 aa(不销毁的栈内存)，在 aa 中创建一个堆内存，把堆内存地址赋值给命名空间 2.这种模式的好处：我们完全可以在 aa 中创造很多内容（变量或函数），那些需要供外面调取使用的，我们暴露到返回的对象中(模块化实现的一种思想）

```javascript
var nameSpace = (function() {
  var n = 12;
  function fn() {
    // ...
  }
  return {
    fn: fn
  };
})();
```

### 基于构造函数创建自定义类（constructor）

> 1.在普通函数执行的基础上"new xxx()",这样就不是普通的函数执行了，二十构造函数执行，当前函数名称之为“类名”，接收返回的结果是当前类的一个实例 2.类名首字母大写 3.这中构造函数设计模式执行，主要用于组件，类库，插件，框架等的封装，平时编写业务逻辑一般不这样处理

```javascript
function fn() {}
var f = new fn();
```

```javascript
function fn() {}
// =>普通函数执行
/*
 * 1.形成私有作用域
 * 2.形参赋值
 * 3.变量提升
 * 4.代码执行
 * 5.栈内存释放
 */

// =>构造函数执行
/*
 * 1.像普通函数执行一样形成一个私有作用域（栈内存）
 * 2.形参赋值-变量提升-
 * 3.【构造函数执行独有】，在js代码自上而下执行之前，首先在当前的私有栈中创建一个对象（暂时不存储任何的东西），并且让函数中的执行主体（this）指向这个新的堆内存
 * 4.代码自上而下执行
 * 5.【构造函数执行独有】，代码执行完成，把之前创建的堆内存地址返回（浏览器默认返回），也就是开始创建的对象其实就是当前Fn这个类的一个实例，我们让this指向这个实例，代码执行中的this.xxx = xxx 都是给实例设置“私有属性”，最后浏览器会默认把创建的实例返回，供外面接收
 *
 * 6. 再次执行new Fn，就是把上面的操作克隆一份，会形成新的实例（新的内存空间），所以说实例是独立分开的
 * 7.构造函数执行，不写return，浏览器会默认返回默认的实例，但是如果我们写了return
 * 7.1 如果return的是一个基本值，返回的结果依然是类的实例，没有收到英雄
 * 7.2 如果返回的是引用类型，则会把默认返回的实例覆盖，此时接收到的结果就不是当前类的实例了
 * 8.构造函数执行的时候，尽量减少return的使用，防止覆盖实例
 */
```
