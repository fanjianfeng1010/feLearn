- 客户端

  - 所有可以向服务器发送请求的一端都是客户端

- 服务器端

  - 所有可以接受客户端请求，并且给其相应一些内容的都是服务器

- DNS 域名解析服务器
  - 记录域名解析记录

打开一个浏览器，在地址栏输入一个地址，按下 enter 键后，看到整个页面中，发生了什么事情？

- HTTP 请求阶段:向服务器发送请求
  - 1. 浏览器首先向 DNS 域名服务器发送请求
  - 2. DNS 反解析，根据浏览器请求地址中的域名，到 DNS 服务器中找到对应的服务器外网 IP 地址
  - 3. 通过找到的外网 IP，向对应的服务器发送请求(首先访问服务器的 web 站点管理工具:准确来说是我们先基于工具在服务器中创建很多服务，当有客户端访问的时候，服务器会匹配出具体是请求哪个服务)
- HTTP 响应阶段:服务器把客户端需要的内容准备好，并且返回给客户端
  - 4. 通过 URL 地址中携带的端口号，找到服务器上对应的服务，以及服务所管理的项目源文件
  - 5. 服务器断根据请求地址中的路径名称，问号传参或者哈希值，把客户端需要的内容进行准备和处理
  - 6. 把准备的内容响应给客户端(如果请求的是 HTML 或者是 CSS 等这样的资源文件，服务器返回的是资源文件中的源代码(不是文件本身))
- 浏览器渲染阶段
  - 7. 客户端浏览器接收到服务器返回的源代码，基于自己内部的渲染引擎(内核)开始进行页面的绘制和渲染
       -> 首先计算 DOM 结构，生成 DOM tree
       -> 自上而下运行代码，加载 css 等资源内容
       -> 根据获取的 CSS 生成带样式的 render tree
       -> 开始渲染和绘制

2. 我们把一次完整的 请求+响应 称之为"HTTP 事务"
   事务就是完整的一次操作，请求和响应缺一不可

3. 一个页面完全加载完成，需要向服务器发起很多次 HTTP 事务操作
   一般来说:首先把 HTML 源代码拿回来，加载 HTML 的时候，遇到 link/script/img[src]/iframe/video 和 audio...都会重新和服务器端建立 HTTP 事务交互

   特殊情况:如果我们做了资源缓存处理（304）,而且即将加载的资源在之前已经加载过了，这样的操作和传统的 HTTP 事务有所不同，他们是从服务器和浏览器的缓存中的读取数据，比传统读取快很多

4. 在客户端向服务器发送请求，以及服务器把内容响应给客户端的时候，中间相互传递了很多内容(客户端把一些内容传递给服务器，服务器把一些内容响应给客户端)，我们把传递的内容成为“HTTP 报文”

### 一个完整的 url 的组成

1. url/urn/uri
   uri = url + urn
   uri:统一资源标识符
   url:统一资源定位符
   urn:统一资源名称

2. http://www.fanjiamfeng.com:80/index.html?name=xxx&age=25#bloger

[传输协议]
用来传输客户端和服务器端交互的信息
http:超文本传输协议(除了传递普通的文本，还昆虫传递文件流或者进制编码等信息)，是目前最常用的 web 传输协议
https:基于 ssl 加密的 HTTP 传输协议，比 HTTP 更加的安全(涉及支付的网站一般都是基于 HTTPS 完成的)
ftp:文件传输协议，一般用来实现资源文件在服务器长的上传下载

[域名]

- 一级域名(顶级域名) www.qq.com
- 二级域名 sports.qq.com
- 三级域名 kbs.sports.qq.com

[端口号]

- 用来区分一台服务器上不同服务的标识(基于 web 服务器管理创建服务的时候可以指定)，不同服务之间一般是不能使用相同的端口号的

- http =>默认端口号 80
- HTTPS => 默认端口号 443
- FTP => 默认端口号 21
  如果当前网站服务，采用的是协议对应的默认端口管理，那么当用户输入网址的时候可以不指定端口号，浏览器会默认把用户默认的端口号传递给服务器

一台服务器上的端口号范围:0~65535 之间
服务器上安装一款应用都肯会作为一个服务，占用一个端口号

[请求路径名称]

- path
- pathname
  - 例如:/stu/index.html 一般都是请求当前服务器对应的项目目录，stu 文件夹中的 index.html 页面，但是也有特殊情况，就是当前的 URL 是被“伪 URL 重写”的，我们请求看到的 URL 请求其实不是真实的请求，而是由服务器动态生成的 DHTML 页面

[问号传参以及哈希值]

- ?xxx=xxx..#xxx
  在 HTTP 事务中，问号传参是客户端把信息传递给服务器的一种方式(也可能是跳转到某一个页面，把参数传递给页面用来标识的)，

  哈希值一般都跟客户端服务器交互没什么关系，主要用于页面中的描点定位和 hash 路由切换

### http 报文

起始行:请求起始行，响应起始行
首部(头):请求头、响应头、通用头
主体:请求主体、响应主体

General 通用头

```
Request URL: https://www.zhihu.com/  请求地址
Request Method: GET                  请求方式:GET/POST/DELETE/PUT/HEAD/OPTION..
Status Code: 200                     响应的HTTP状态码
Remote Address: 118.89.204.190:443   主机地址(服务器外网IP地址)
Referrer Policy: no-referrer-when-downgrade 来源信息，用来分析用户从哪里来的
```

Request Header 请求头[客户端设置，服务器接收]

```
GET / HTTP/1.1      =>起始行(描述当前请求的一些基本信息， 用的是1.1版本传输协议进行内容传输的)
Host: www.zhufengpeixun.com
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cookie:... => cookie信息一般都是放到头文件中实现和服务器端的数据通信的

```

Response Header 响应头 [服务器的设置，客户端获取]

```
HTTP/1.1 200 OK    => 起始行(HTTP状态码)
Date: Thu, 25 Apr 2019 09:36:02 GMT  => 服务器响应内容时候的“服务器端时间” （客户端获取这个时间的时候已经和真实时间产生误差了，因为服务器返回内容到客户端接收到，也是需要时间的），并且这个时间是格林尼治时间(比北京时间慢8小时)
Server: Apache   =>管理web服务器的工具
Last-Modified: Mon, 22 Apr 2019 10:22:27 GMT
ETag: "5c0cf3-f7a9-5871bd864aa48"
Accept-Ranges: bytes
Vary: Accept-Encoding,User-Agent
Content-Encoding: gzip
Content-Length: 12700
Keep-Alive: timeout=15, max=300
Connection: Keep-Alive
Content-Type: text/html

```

Response [响应主体]

```
  服务器返回的是什么就是什么
```

Request Payload / Form Data [请求主体]

```
  客户端传递给服务器的内容
```

了解 HTTP 报文以及如何查看对未来工作开发和 bug 调试至关重要
，以后涉及到交互功能(前端<=>后台)出现问题，都按照如下方式查找问题原因
A:打开控制台，在 net-work 中找到当前交互的请求地址，点击进去看详情
B:如果是传递给服务器的参数或者方式错误【前端问题】
C:如果服务器返回的信息有错误或者和 api 接口文档的内容不一样【后端问题】
D:如果返回数据是对的，但是展示有问题[前端问题]

确定是自己前端的问题后，基于断电或者控制台输出等方式，开始逐步调试即可

3. 客户端和服务器端信息交互的方式
   [客户端传递给服务器]
   A:问号传参=>请求的 URL 地址末尾通过问号传参方式，把一些信息传递给服务器

   B:设置请求头
   客户端把需要传递给服务器的内容设置到请求头信息中(自定义请求头)，服务器可以通过接收请求头把信息内容得到

   C:设置请求主体
   xhr.send([ajax send]中传递的内容，就是客户端设置的请求主体内容，服务器端可以接收到这些信息)

[服务器返回给客户端]
A:设置响应头信息
例如把服务器通过响应头返回给客户端，客户端通过获取响应头信息得到这个时间(响应头返回的速度是优先于响应主体的)

B:设置响应主体
主要的返回信息都在响应主体中

### 前端性能优化方案

- 1. 在 JS 中尽量减少闭包的使用（原因是因为闭包会产生不释放的栈内存）
- A:循环给元素做时间绑定的时候，尽可能的把后期需要的信息(例如索引)存储到元素的自定义属性上，而不是创建闭包存储
- B:可以在最外层形成一个闭包，把一些后续需要的公共信息进行存储，而不是每一个方法都创建闭包(例如单例模式)
- C:尽可能手动释放不被占用的内存

- 2. 尽量合并 css 和 js 文件(把需要引入的 css、js 合并为一个)，原理是在减少 HTTP 请求次数，金肯的把合并后的代码进行压缩，减少 HTTP 请求资源的大小

  - A:webpack 这种自动化构建工具，可以帮我们事先代码的合并和压缩(工程化开发)
  - B:在移动开发(或者追求高性能的 pc 端开发【例如百度首页】)，如果 CSS 或者 js 不是需要很多，我们可以选择把 css 和 js 编程内嵌式(也就是直接在 HTML 中写代码)

- 3. 尽量使用字体图标或者 svg 图标，来代替传统的 png 等格式的图片(因为字体图标等是矢量图)，放大不会变形，渲染速度快，相对比位图要小一些

- 4. 减少 dom 的操作（主要是减少 DOM 的重绘和回流(重排)）

  - A:关于重排的分离读写
  - B:使用文档碎片或者字符串拼接做数据绑定(DOM 的动态创建)

- 5. 在 js 中避免“嵌套循环”和“死循环”

- 6. 采用图片的懒加载（延迟加载）

  - 目的是为了减少页面第一次加载过程中 HTTP 的请求次数
  - 步骤：开始加载页面的时候，把所有的真实图片都不去发送 HTTP 请求加载，二十给一张站位的背景图，当页面加载完，并且图片在可视区我们再去加载真实图片

- 7. 利用浏览器和服务器端的缓存技术(304 缓存)，把一些不经常更新的静态资源文件做缓存处理(例如:js、css、静态图片等都可以做缓存)

  - 原理也是为了减少 HTTP 请求次数和请求大小，让获取速度更快

- 8. 尽可能使用事件委托(事件代理)来处理事件绑定的操作，减少 dom 的频繁操作，其中包括给每一个 dom 元素做事件绑定

- 9. 尽量减少 css 表达式的使用

- 10. css 选择器的解析规则是从右向左解析的
  - 先找到所有的 a 再筛选.link 样式类中的，再次筛选.contaner 样式类中的。。。先找到所有的 A，操作起来是消耗性能的，我们在使用 css 选择器的时候尽量可能减少对标签选择器的使用

```
  .container .link a {

  }
```

- 11. css 雪碧图技术(css sprite / css 图片精灵)

  - 把所有相对小资源图片汇总到一张大图上，后期我们只需要把大图加载下来，用背景定位的方式展示对应的小图即可

  ```
    .bg {
      background:url('xxx.png');
    }
    .box1{
      background-position:xx xx;
    }
    .box2{
      bacrground:position:xx xxx;
    }
    <div class = 'bg box1'></div>
  ```

- 12. 减少对于 cookie 的使用(主要减少本地 cookie 存储的大小)，因为客户端操作 cookie 的时候，这些信息总是在客户端和服务器端传来传去

- 13. 页面中的数据采取异步编程和延迟分批加载

  - 使用异步获取数据，是为了降低 HTTP 通道的堵塞，不会因为数据没有情趣来回耽误下面信息的渲染，提高页面的打开速度(我们可以这样处理:需要动态绑定数据的区域先隐藏，等数据返回并且绑定完成后再让其显示)
  - 延迟分批加载类似于图片懒加载，是为了减少第一次页面加载的时候 HTTP 请求次数

- 14. 页面出现音视频标签，我们不让页面加载的时候就去加载这些资源(要不然页面加载速度会变慢)(方案:只需要设置 preload='none'即可)，等页面加载完成，音视频播放的时候我们再去加载音视频资源

- 15. 在客户端和服务器端进行信息交互的时候，对于多项数据我们尽可能基于 json 格式来进行传送(json 格式的数据处理方便，资源偏小) ===> 相对于 xml 格式的传输才会有这个优势

- 16. 尽可能实现 js 的封装（低耦合高内聚），减少页面中的冗余代码(减少 HTTP 请求资源的大小)

- 17. 在基于 Ajax 的 get 请求进行数据交互的时候，根据需求可以让其产生缓存(这个缓存不是 304 缓存)，这样下一次从相同地址获取的数据是上一次缓存的数据(但是很少用，项目中一般可以清除这个缓存的时候偏多)

* 额外技巧
  - 我们一般都把 CSS 放到 body 上，把 js 放到 body 下面（让 css 先加载再加载 js，先加载 css 是为了保证页面渲染过程中，元素是带着样式渲染的，而 js 一般是用来操作 DOM 的，需要等元素加载完成再操作）
  - 能用 css 搞定的绝对不用 js,能用原生 js 搞定的绝对不用插件，绝对不使用 flash
    => css 处理动画的性能优于 JS，而且 css 中的 transform 变形还开启了浏览器的硬件加速
  - js 中尽量减少对 eval 的使用，因为 js 合并压缩的时候，可能会出现符号不完善，导致代码执行优先级错乱
