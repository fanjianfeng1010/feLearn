#### 基本类型变量声明

```javascript
var a = 12;
```

> 1.先声明一个变量 a，没有赋值（默认值是 undefined） 2.在当前作用域开辟一个内存空间存储 12 这个值 3.让变量 a 与 12 关联在一起（定义：赋值）

#### 引用类型变量声明

```javascript
var obj = {
  name: "xxx",
  age: 12
};
```

> 1.首先开辟一片内存空间，把对象里面的内容按照键值对形式依次存储起来，为了以后能找到这篇空间，这片空间有一个 16 进制的地址 2.声明一个变量 3.把变量和地址关联起来

#### 变量提升

> 变量提升只发生在当前作用域
> 当栈内存(作用域)形成，JS 代码自上而下执行之前，浏览器首先会把所有带‘var/function’关键词的进行提前的声明，这种预先处理的机制称之为‘变量提升’
> 声明:var a
> 定义:a = 12
> 变量提升阶段
> 带‘var‘的只声明未定义
> 带’function‘的声明和定义都完成了
> 在当前作用域下，不管条件是否成立，都会进行变量提升
> => 带 var 的还是只声明
> => 带 function 的在老版本浏览器渲染机制下，声明+定义都处理，但是为了迎合 ES6 的块级作用域，新版本浏览器对于函数（在条件判断中的函数），不管条件是否成立，都只声明，没有定义

```javascript
console.log(a); // => undefined
if (1 === 2) {
  var a = 12;
}
console.log(a); // => 12

console.log(fn); // =>undefined
if (1 === 1) {
  console.log(fn); // => ƒ fn() {console.log(fn)}
  function fn() {
    console.log(fn);
  }
}
console.log(fn); // ƒ fn() {console.log(fn)}

console.log(`${fn} 第一行`); // =>undefined
if (1 === 2) {
  console.log(`${fn} 第二行`); // 没有执行

  function fn() {
    console.log(fn);
  }
}
console.log(`${fn} 第三行`); // undefined
```

> 在 ES6 中，用 let 和 const 定义的变量/函数不存在变量提升，并且切断了全局变量和 window 属性的映射机制

```javascript
let a = 12;
console.log(window.a); // => undefined
console.log(a); // => 12
```

> 虽然没有变量提升机制，但是在当前作用域代码自上而下执行之前，浏览器会做一个重复性检测（语法检测)，一旦发现有重复的，直接抛出异常，代码也不会再执行了（虽然没有变量提前声明，但是浏览器已经记住了当前作用域下有哪些变量）

> 暂时性死区

```javascript
var temp = 12;
if (true) {
  console.log(a);
  let temp = 1;
} // => Uncaught ReferenceError: a is not defined
```

### JS 中的堆栈内存释放

> js 中的内存分为堆内存和栈内存
> 堆内存：存储引用数据类型（对象:键值对，函数:代码字符串）
> 栈内存：提供 js 代码执行的环境和存储基本类型的值
> [堆内存释放]：让所有引用堆内存空间地址的变量赋值为 null 即可
> [栈内存释放]：一般情况下，当函数执行完成，所形成的私有作用域(栈内存)都会自动释放（在栈内存中存储的值也会释放掉），但是也有特殊不销毁的情况:
> 1、函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量引用了，此时栈内存不能释放（一旦释放，外面找不到原有内容了）
> 2、全局栈内存只有在页面关闭的时候才会释放掉
> 如果当前栈内存没有被释放，那么之前在栈内存中存储的基本值也不会被释放，内容能一直被保存下来

```javascript
var i = 1;
function fn(i) {
  return function(n) {
    console.log(n + ++i);
  };
}
var f = fn(2); // => i  = 3
f(3); // => n:3  i:4
fn(5) * 6; // i:5 i:6
fn(7) * 8; // i:7 i :8
f(4); // n:4 i:9
```

### 闭包

函数形成一个私有的作用域，保护里面的私有变量不受外界干扰，这种保护机制称之为’闭包‘

形成一个不销毁的私有的作用域（私有栈内存）

```javascript
// 柯理化函数
function fn() {
  return function() {};
}

var f = fn();

//闭包:惰性函数
var utils = (function() {
  return {};
})();
```

真实项目中，为了保证 JS 性能（堆栈内存的性能优化），应该尽可能的减少闭包的使用（不销毁的堆栈内存是耗性能的）

> 1.闭包具有保护作用：保护私有变量不受外界干扰 2.闭包具有保存作用：形成不销毁的栈内存，包一些值保存下来，方便后面的调取使用
